<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Dwarf Programming Language</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./mdbook-admonish.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <img class="sidebar-logo" src="favicon.png">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="overview.html">Language Walkthrough</a></li><li class="chapter-item expanded affix "><li class="part-title">Examples</li><li class="chapter-item expanded "><a href="tutorials/mandelbrot.html"><strong aria-hidden="true">1.</strong> Mandelbrot Set</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorials/mandelbrot/complex.html"><strong aria-hidden="true">1.1.</strong> Coding a Complex Type</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.2.</strong> Mapping Points to Pixels</div></li><li class="chapter-item expanded "><a href="tutorials/mandelbrot/render_0.html"><strong aria-hidden="true">1.3.</strong> Rendering the Set</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.4.</strong> Speeding it up</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Python Bindings</div></li><li class="chapter-item expanded affix "><li class="part-title">Reference</li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Dwarf Language Reference</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">3.1.</strong> Items</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/enums.html"><strong aria-hidden="true">3.1.1.</strong> Enumerations</a></li><li class="chapter-item expanded "><a href="reference/functions.html"><strong aria-hidden="true">3.1.2.</strong> Functions</a></li><li class="chapter-item expanded "><a href="reference/imports.html"><strong aria-hidden="true">3.1.3.</strong> Imports</a></li><li class="chapter-item expanded "><a href="reference/patterns.html"><strong aria-hidden="true">3.1.4.</strong> Patterns</a></li><li class="chapter-item expanded "><a href="reference/structs.html"><strong aria-hidden="true">3.1.5.</strong> Structs</a></li></ol></li><li class="chapter-item expanded "><a href="reference/statements.html"><strong aria-hidden="true">3.2.</strong> Statements</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.3.</strong> Expressions</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/expressions/literal.html"><strong aria-hidden="true">3.3.1.</strong> Literal Expressions</a></li><li class="chapter-item expanded "><a href="reference/expressions/unary.html"><strong aria-hidden="true">3.3.2.</strong> Unary Expressions</a></li><li class="chapter-item expanded "><a href="reference/expressions/binary.html"><strong aria-hidden="true">3.3.3.</strong> Binary Expressions</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.4.</strong> Types</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/built-in-types.html"><strong aria-hidden="true">3.4.1.</strong> Built-in Types</a></li><li class="chapter-item expanded "><a href="reference/udts.html"><strong aria-hidden="true">3.4.2.</strong> User-defined Types</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.5.</strong> Inline Assembly</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.6.</strong> Object Oriented Features</div></li></ol></li><li class="chapter-item expanded "><a href="chacha.html"><strong aria-hidden="true">4.</strong> ChaCha Runtime Reference</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> The Future</div></li><li class="chapter-item expanded "><a href="hacker.html"><strong aria-hidden="true">6.</strong> For Hackers</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> Building</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.1.</strong> Tools</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.2.</strong> Benchmarks</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Architecture</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="hacker/arch/parser.html"><strong aria-hidden="true">6.2.1.</strong> Parser</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.2.</strong> Compiler</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.3.</strong> Chacha</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="hacker/arch/chacha/async.html"><strong aria-hidden="true">6.2.3.1.</strong> Async Implementation</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.3.2.</strong> Interpreter</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.3.3.</strong> VM</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.4.</strong> The ObjectStore</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> Code Generation</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.4.</strong> Dwarf Language</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="hacker/dwarf/generics.html"><strong aria-hidden="true">6.4.1.</strong> Generic Types</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="directory.html">Index</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="preface.html">Postface</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Dwarf Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/uberfoo/dwarf" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><img src="images/dwarf@0.5x.png" alt="The Dwarf Logo" /></p>
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<blockquote>
<p>🚧 This is book is a work in progress. 🚧</p>
</blockquote>
<p>Welcome!
This brief introduction will outline the status of dwarf, and set the stage for what's to come.</p>
<p>Before I get started, I need to state this this is the result of me hacking since April 2023.
As I write this that is about seven month and 80k lines of code ago.
So there is a lot of code, in a relatively short period of time.
Some of it is sloppy.
Some of it very much so.
But it's as correct as I can make it: &quot;in <code>rustc</code> we trust&quot;, and praise be unto Henry and Milner for.
The one thing that it's almost guaranteed not to be is efficient.
I'm sure that I'm copying memory unnecessarily all over the place.
There are other areas ripe for critique, and I appreciate any and all feedback.
I appreciate anyone taking the time to bother to read the code to be honest.</p>
<p>In fact the code is sprinkled with notes to myself, and `// 🚧`` markers.
The simple fact is that you can do it right, or do it quickly, and leave yourself as much context as possible.</p>
<h2 id="hello-world"><a class="header" href="#hello-world"><a name="a001"></a>Hello World</a></h2>
<p>Every language deserves one, so let's get it out of the way.
Go ahead and click the run button in the top right corner of the code-box below.</p>
<pre><pre class="tunnel"><code class="language-dwarf  editable">fn main() {
    let name = &quot;World&quot;;
    print(&quot;Hello &quot; + name + &quot;!&quot;);
}</code></pre></pre>
<p>Feel free to edit the code — replace <code>World</code> with your name maybe?
I know you want to. 😀</p>
<h2 id="a-brief-story-of-dwarf"><a class="header" href="#a-brief-story-of-dwarf">A brief story of dwarf</a></h2>
<blockquote>
<p><strong>Caveat Emptor, Note Bene, etcetera</strong></p>
<p><a name="a002"></a>dwarf (the language and it's implementation, <a name="a003"></a>ChaCha) is very much a work in progress.
The language itself is still evolving, and the implementation is still very much in flux.
I don't honestly see very many breaking changes moving forward, however I can't promise anything until 1.0.</p>
</blockquote>
<p>Dwarf started life as a DSL for another project.
I've had so much fun with it, I want to see if anyone else might find it generally useful.</p>
<p>Because dwarf was intended as a DSL, the focus was not language design.
I'm pretty sure if I had allowed myself that freedom that I'd still be working on it.
And it would be weird...</p>
<p>So I based it on Rust.
It shares most of it's syntax with Rust, while mostly maintaining the behavior of other interpreted languages.
The one big exception is that dwarf is typed, like Rust.</p>
<p>That said, there is a lot missing.
Traits for example are not to be found.
Neither are there generics, or iterator adaptors.
Enums are also a glaring absence.
Some of these are missing only because I wanted to get this out the door.
Others, like traits, may not have a place, and they may.
It's all very unclear at this point, and will likely depend on demand.
Other's, and those of my needs.</p>
<p>Right now dwarf is also very slow.
(He's still working on his tunneling gear apparently.)
It's slow because it's interpreted, and the foundations of the interpreter are not really built for speed.
That said, there is a VM currently in the works, and it's already integrated with the interpreter to speed some things up.</p>
<p>Along the way I wrote a &quot;debugger&quot; and a REPL.
The debugger is very basic.
You have to set debugger statements in your code to get it to stop — there is no way to set a breakpoint form the tool.
Once the program has stopped single stepping through the code is possible.
There is also a &quot;run&quot; button to start it going again.</p>
<p>I began work on a DAP for VSCode (and others), but the documentation on the wire protocol is not easy to find.
I put this on the shelf in favor of just publishing something a little more polished.</p>
<p>The REPL is really nice for playing around with the language.
It's also a great way to prototype ideas.</p>
<p>So, thanks for taking a look, I hope you enjoy what you find!</p>
<blockquote>
<p><strong>A note regarding the code in this book:</strong></p>
<p>The code snippets contained herein are executed by AWS Lambda.
I've mentioned elsewhere that the interpreter is not fast.
Running as a lambda, it's even not faster... er, slower. 😎</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="language-walkthrough"><a class="header" href="#language-walkthrough">Language Walkthrough</a></h1>
<p>Thanks for reading thus far!
This section is a walkthrough of the language.
It is designed to provide information in an order useful to someone new to programming.</p>
<h2 id="a-quick-program"><a class="header" href="#a-quick-program">A Quick Program</a></h2>
<p>This will be a motivating example for the rest of the section:</p>
<pre><pre class="tunnel"><code class="language-dwarf">fn print_number(n: int) {
    print(&quot;the number is {0}\n&quot;.format(n));
}

fn main() {
    let a = 42;
    print_number(a);
}</code></pre></pre>
<h2 id="functions-and-statements"><a class="header" href="#functions-and-statements">Functions and Statements</a></h2>
<p>Let's start with <a name="a001"></a>functions and <a name="a002"></a>statements.
Functions are composed of statements between curly braces.
You already saw a function in the <a href="./introduction.html">introduction</a>.
That function printed <a name="a003"></a><code>()</code> after the <code>Hello, world!</code> message.
In dwarf we just call that the <a name="a004"></a>empty type/value.
It's a type, and a value, and it's the only value of it's type.
A function (and any <a name="a005"></a>block for that matter) returns the value of it's last statement.
A statement that ends in a semi-colon has the empty value:</p>
<pre><pre class="tunnel"><code class="language-dwarf">fn main() {
    print(&quot;&quot;);
}</code></pre></pre>
<p>On the other hand, a statement that does not terminate in a semi-colon has the value of it's expression:</p>
<pre><pre class="tunnel"><code class="language-dwarf">fn main() -&gt; int {
    42
}</code></pre></pre>
<blockquote>
<p><strong>Expressions</strong></p>
<p>There will be a lot more to say about expressions later.
For now just know that basically everything in dwarf is an expression.</p>
</blockquote>
<h3 id="let-statement"><a class="header" href="#let-statement">Let Statement</a></h3>
<p>Not all statements are composed of expressions.
In particular is the <a name="a006"></a><code>let</code> statement.
Since the let statement has no value, it must be terminated with a semi-colon.
The following is not valid and throws an error:</p>
<pre><pre class="tunnel"><code class="language-dwarf">fn main() {
    let a = 42
}</code></pre></pre>
<p>The let statement is instead used to assign a value to a storage location, or memory.
The storage location is called a <a name="a007"></a>variable, and has a name.
You use the name to refer to the variable elsewhere in the function:</p>
<pre><pre class="tunnel"><code class="language-dwarf">fn main() {
    let a = 42;
    print(a);
}</code></pre></pre>
<p>Getting back to functions, functions take inputs, do something with them, and return an output.
The following code defines a function that takes an integer, does some computation, and returns a string.</p>
<pre><pre class="tunnel"><code class="language-dwarf"><span class="boring">#fn main() {
</span>fn foo(a: int) -&gt; string {
    let b = a * 2;
    &quot;The value of b is {1}. This is here just to confuse you, {0}&quot;.format(&quot;hah!&quot;, b)
}

print(foo(42) + &quot;\n&quot;);
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Advanced Statements</strong></p>
<p>There is a third type of statement, called an <a name="a008"></a>item statement.
It's useful for defining <a name="a009"></a>structs and <a name="a010"></a>functions inside of a <a name="a011"></a>block expression.
Below is an example of both:</p>
<pre><pre class="tunnel"><code class="language-dwarf">fn main() {
    struct Point {
        x: float,
        y: float,
    }

   impl Point {
       fn new(x: float, y: float) -&gt; Point {
           Point { x: x, y: y }
       }
   }

    fn foo() -&gt; Point {
        Point::new(42.0, -3.14)
    }

    print(foo());
}</code></pre></pre>
</blockquote>
<h2 id="conditional-expressions"><a class="header" href="#conditional-expressions">Conditional Expressions</a></h2>
<p>Next up is the <a name="a012"></a>conditional expression.
Conditional expressions are used to make decisions.
They are composed of three parts: a <a name="a013"></a>condition, a <a name="a014"></a>then expression, and an <a name="a015"></a>else expression.
The condition is an expression that evaluates to a boolean value.
The then and else expressions are expressions that evaluate to the same type.
The type of the conditional expression is the type of the then and else expressions.
The following is an example of a conditional expression:</p>
<pre><pre class="tunnel"><code class="language-dwarf">fn main() {
    let a = 42;
    let b = 69;
    let c = if a &gt; b { a } else { b };
    print(c);
}</code></pre></pre>
<blockquote>
<p><strong>Expression Magic</strong></p>
<p>Having everything as an expression pays great dividends.
In the example above notice how we assign <code>c</code> to the result of the <a name="a016"></a><code>if</code> expression.
<code>if</code> actually has a value, which is the value of it's evaluation.
It's expressions all the way down. 🥁</p>
</blockquote>
<p>There are all the usual <a name="a017"></a>comparison operators: <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>:</p>
<pre><pre class="tunnel"><code class="language-dwarf">fn main() {
    chacha::assert_eq(42 == 42, true);
    chacha::assert_eq(42 != 42, false);
    chacha::assert_eq(42 &lt; 42, false);
    chacha::assert_eq(42 &lt;= 42, true);
    chacha::assert_eq(42 &gt; 42, false);
    chacha::assert_eq(42 &gt;= 42, true);
}</code></pre></pre>
<pre><pre class="tunnel"><code class="language-dwarf"><span class="boring">#fn main() {
</span>//macro_rules! println {
//    () =&gt; {
//        print(&quot;\n&quot;);
//    },
//    ($arg:expr) =&gt; {
//        print($arg as string + &quot;\n&quot;);
//    },
//    ($fmt:literal, $($arg:expr),*) =&gt; {
//        print($fmt.format($($arg),*) + &quot;\n&quot;);
//    }
//}

//printtln!();
print(&quot;\n&quot;);
//println!(&quot;Hello, world!&quot;);
print(&quot;Hello, world!&quot; as string + &quot;\n&quot;);
//println!(&quot;The answer is {0}, what's the {1}&quot;, 42, &quot;question?&quot;);
print(&quot;The answer is {0}, what's the {1}&quot;.format(42, &quot;question?&quot;) + &quot;\n&quot;);
//println!(42);
print(42 as string + &quot;\n&quot;);
<span class="boring">}</span></code></pre></pre>
<h2 id="golden-nuggets-"><a class="header" href="#golden-nuggets-">Golden Nuggets ⭐️🌟✨</a></h2>
<ol start="0">
<li>
<p>The interpreter is called <a name="a018"></a>ChaCha, but the binary is called <code>dwarf</code>.
Go figure.</p>
</li>
<li>
<p>I call input files <code>.tao</code>, I don't remember why.
None of the tooling cares what you name them.</p>
</li>
<li>
<p>The interpreter looks for a <a name="a019"></a><code>main</code> function, where it will begin execution.</p>
</li>
</ol>
<pre><pre class="tunnel"><code class="language-dwarf">fn main() {
    print(&quot;Hello, world!\n&quot;);
}</code></pre></pre>
<p>Passing <a name="a020"></a>command line arguments to main from the interpreter is <a href="./chacha.html#args">supported</a>.</p>
<ol start="0">
<li>In dwarf, just about everything is an <a name="a021"></a>expression.
The only thing that is not an expression is a <a name="a022"></a><code>let</code> statement.
That's not true.
Items inside blocks are also statements.
So that's only two things that I can think of.
Putting a semicolon at the end of an expression makes it a statement, but it's still an expression underneath.
This is super powerful, and allows for some really cool things.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mandelbrot-set"><a class="header" href="#mandelbrot-set">Mandelbrot Set</a></h1>
<p>I imagine that everyone is familiar with the <a name="a001"></a>Mandelbrot set.
It's a <a name="a002"></a>fractal that is generated by iterating a function over the complex plane.
It makes really nifty pictures.
<a href="https://www.youtube.com/watch?v=b005iHf8Z3g"><img src="https://img.youtube.com/vi/b005iHf8Z3g/0.jpg" alt="mandelbrot" /></a>.</p>
<p>Doing this in dwarf is not as pretty, as dwarf can only output to the terminal using the <a name="a003"></a><code>print</code> expression.
So ours is going to end up looking more like the first-ever image of the set:
<img src="tutorials/./mandelbrot_orig.png" alt="mandelbrot-orig" />.</p>
<p>The function that we'll be iterating to draw the set is really simple: \(f(z) = z^2 + c\), where \(z\) and \(c\) are both complex numbers.
Basically, you fall within the set if \(z\) does not go to \(\infty\) when you iterate the function.</p>
<p>I mentioned that the set is over the complex plane, and dwarf doesn't grok ((i: complex numbers}}.
That means that we'll need to invent our own complex type.
As per above, we'll need to support addition and squaring.
So, let's get started!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="coding-a-complex-type"><a class="header" href="#coding-a-complex-type">Coding a Complex Type</a></h1>
<p><a name="a001"></a>Complex numbers are really just a <a name="a002"></a>tuple of two <a name="a003"></a><code>float</code>s.
One element is the real part of the number, and the other is the imaginary part.
The real part is plotted along the x-axis, and the imaginary part is plotted along the y-axis.</p>
<p>Addition and subtraction are defined as you would expect: perform the operation on the real and imaginary parts independently, e.g.: \((a, m) + (b, n) = (a + b, m + n)\).
To multiply two complex numbers, one must refer back to multiplying two binomials: \((a + bi)(c + di) = bdi^2 + bci + adi + ac = bci + adi + ac - bd\).
But don't get caught up in the math — it's not on the test.</p>
<h2 id="defining-the-type"><a class="header" href="#defining-the-type">Defining the Type</a></h2>
<p>dwarf doesn't have tuples (yet) so we'll use <a name="a004"></a><code>struct</code>s like so:</p>
<pre><pre class="tunnel"><code class="language-dwarf"><span class="boring">#fn main() {
</span>struct Complex {
    re: float,
    im: float,
}
<span class="boring">}</span></code></pre></pre>
<p>This is how we declare a user defined type in dwarf.
It's the keyword <em>struct</em> followed by the name of the type, and then a block of fields.
Each field in the block is a name followed by a type, separated by a colon.
Each field is separated from another by a comma.
Trailing commas are just fine.</p>
<p>In this specific case we have a <em>struct</em> called <code>Complex</code> that has two fields, each of type <em>float</em>.
The first is called <code>re</code>, and the second, <code>im</code>.</p>
<p>Initialization of a <em>struct</em> is done by a <em><a name="a005"></a>struct expression</em>, just like Rust.
if you are unfamiliar, a struct expression looks like the definition, but with values in place of types.</p>
<pre><pre class="tunnel"><code class="language-dwarf"><span class="boring">struct Complex {
</span><span class="boring">   re: float,
</span><span class="boring">   im: float,
</span><span class="boring">}
</span>fn main() {
    let z = Complex {
        re: 1.23,
        im: 4.56,
    };
    chacha::assert_eq(z.re, 1.23);
    chacha::assert_eq(z.im, 4.56);
}</code></pre></pre>
<p>The last two lines are functions provided by the runtime <a name="a006"></a>ChaCha.
<code>chacha::assert_eq</code> tests it's arguments for equality, and throws an error if they are not.</p>
<h2 id="complex-methods"><a class="header" href="#complex-methods">Complex Methods</a></h2>
<p>Having a type is a good start.
We can now create Complex numbers</p>
<h3 id="addition"><a class="header" href="#addition">Addition</a></h3>
<p>Addition is fairly straightforward:</p>
<pre><pre class="tunnel"><code class="language-dwarf"><span class="boring">#fn main() {
</span><span class="boring">struct Complex {
</span><span class="boring">    re: float,
</span><span class="boring">    im: float,
</span><span class="boring">}
</span>
impl Complex {
    fn add(self, other: Complex) {
        self.re = self.re + other.re;
        self.im = self.im + other.im;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This is an <em>impl</em> block.
Functions that belong to the <em>struct</em> go into the <em>impl</em> block.</p>
<h3 id="squared"><a class="header" href="#squared">Squared</a></h3>
<p>Similarly, the square function is not too bad:</p>
<pre><pre class="tunnel"><code class="language-dwarf"><span class="boring">#fn main() {
</span><span class="boring">struct Complex {
</span><span class="boring">    re: float,
</span><span class="boring">    im: float,
</span><span class="boring">}
</span>
impl Complex {
    fn square(self) {
        self.re = self.re * self.re - self.im * self.im;
        self.im = 2.0 * self.re * self.im;
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="a-shortcut"><a class="header" href="#a-shortcut">A Shortcut</a></h3>
<p>Earlier I said that you know if you are in the set if you don't go to infinity and beyond.
We don't have that much time, and there's a shortcut.
While we are iterating, we can just check the absolute value of the complex number.
If it is greater than 2 then we know that the number will go to infinity.
When that happens we know that we are not in the set.</p>
<p>Rather than check the absolute value, we can just check of the value is greater than 4.
The problem of course is that 4 is a scalar, and we are dealing with complex numbers.
The solution is to take the <em>norm</em>, or <em>dot product</em> of the complex number.</p>
<pre><pre class="tunnel"><code class="language-dwarf"><span class="boring">#fn main() {
</span><span class="boring">struct Complex {
</span><span class="boring">    re: float,
</span><span class="boring">    im: float,
</span><span class="boring">}
</span>
impl Complex {
    fn norm(self) -&gt; float {
        self.re * self.re + self.im * self.im
    }
}
<span class="boring">}</span></code></pre></pre>
<p>There is something worth noting in the last function.
We are returning a <em>float</em>, but there is no <em>return</em> statement.
Just like in Rust, the last expression in a <em>block</em> is the the value of the block.</p>
<h3 id="zero"><a class="header" href="#zero">Zero</a></h3>
<p>We'll need to be able to create the Complex number &quot;0&quot;.
We can do that with a <em><a name="a007"></a>static method</em>.
Static methods are functions that belong to the type, rather than an instance of the type.
Practically that means that the function does not take a <em>self</em> parameter.</p>
<pre><pre class="tunnel"><code class="language-dwarf"><span class="boring">struct Complex {
</span><span class="boring">   re: float,
</span><span class="boring">   im: float,
</span><span class="boring">}
</span>
impl Complex {
    fn zero() -&gt; Complex {
        Complex {
            re: 0.0,
            im: 0.0,
        }
    }
}

fn main() {
    let zero = Complex::zero();
    chacha::assert_eq(zero.re, 0.0);
    chacha::assert_eq(zero.im, 0.0);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rendering-the-set"><a class="header" href="#rendering-the-set">Rendering the Set</a></h1>
<pre><pre class="tunnel"><code class="language-dwarf  editable">struct Complex {
    re: float,
    im: float,
}

impl Complex {
    fn zero() -&gt; Complex {
        Complex { re: 0.0, im: 0.0 }
    }

    fn add(self, other: Complex) -&gt; Complex {
        Complex {
            re: self.re + other.re,
            im: self.im + other.im,
        }
    }

    fn add_2(self, other: Complex) {
        self.re = self.re + other.re;
        self.im = self.im + other.im;
    }

    fn square(self) -&gt; Complex {
        Complex {
            re: self.re * self.re - self.im * self.im,
            im: 2.0 * self.re * self.im,
        }
    }

    fn square_2(self) {
        let re = self.re * self.re - self.im * self.im;
        self.im = 2.0 * self.re * self.im;
        self.re = re;
    }

    fn norm_squared(self) -&gt; float {
        self.re * self.re + self.im * self.im
    }
}

fn pixel_to_point(
    width: int,
    height: int,
    pixel_x: int,
    pixel_y: int,
    upper_left: Complex,
    lower_right: Complex,
) -&gt; Complex {
    let w = lower_right.re - upper_left.re;
    let h = upper_left.im - lower_right.im;
    Complex {
        re: upper_left.re + pixel_x as float * w / width as float,
        im: upper_left.im - pixel_y as float * h / height as float,
    }
}

fn escape_time(c: Complex, limit: int) -&gt; int {
    // debugger;
    let z = Complex::zero();
    for i in 1..limit {
        // z = Complex::square(z);
        // z = Complex::add(z, c);
        // z.square_2();
        // z.add_2(c);
        ComplexEx::square(z);
        ComplexEx::add(z, c);
        let foo = ComplexEx::norm_squared(z);
        if foo &gt; 4.0 {
            return i;
        }
    }
    0
}

fn main() -&gt; () {
    print(&quot;Total time: {0}s\n&quot;.format(chacha::time(plot)));
}

fn plot() -&gt; () {
    let width = 42;
    let height = 10;
    let upper_left = Complex { re: -2.5, im: 1.0 };
    let lower_right = Complex { re: 2.0, im: -1.0 };
        let t = 50;
        for row in 0..height {
            do_column(t, row, width, height, upper_left, lower_right);
        }

    print(&quot;{0}\n&quot;.format(chacha::eps()));
}

fn do_column(time: int, row: int, width: int, height: int, upper_left: Complex, lower_right: Complex) {
    for column in 0..width {
        let point = pixel_to_point(width, height, column, row, upper_left, lower_right);
        let time = escape_time(point, time);
        if time &gt; 0 {
            print(&quot; &quot;);
        } else {
            print(&quot;*&quot;);
        }
    }
    print(&quot;\n&quot;);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enumerations"><a class="header" href="#enumerations">Enumerations</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="imports"><a class="header" href="#imports">Imports</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="patterns"><a class="header" href="#patterns">Patterns</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs"><a class="header" href="#structs">Structs</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="statements"><a class="header" href="#statements">Statements</a></h1>
<p>dwarf, like Rust uses only a handful <a name="a001"></a>statements.</p>
<h2 id="let-statement-1"><a class="header" href="#let-statement-1"><a name="a002"></a>Let Statement</a></h2>
<p>The <a name="a003"></a><code>let</code> statement is used to assign a value to a variable.</p>
<pre><pre class="tunnel"><code class="language-dwarf"><span class="boring">#fn main() {
</span>let x = 42;
<span class="boring">}</span></code></pre></pre>
<h2 id="expression-statement"><a class="header" href="#expression-statement"><a name="a004"></a>Expression Statement</a></h2>
<h2 id="result-statement"><a class="header" href="#result-statement"><a name="a005"></a>Result Statement</a></h2>
<pre><pre class="tunnel"><code class="language-dwarf"><span class="boring">#fn main() {
</span>fn empty() -&gt; () {
    42;
}

fn value() -&gt; int {
    42
}

print(empty());
print(value());

print({});
print({42});
<span class="boring">}</span></code></pre></pre>
<h2 id="item-statement"><a class="header" href="#item-statement"><a name="a006"></a>Item Statement</a></h2>
<pre><pre class="tunnel"><code class="language-dwarf">fn main() -&gt; () {
    // This is aa item statement.
    // Note the lack of a semicolon.
    struct Point {
        x: float,
        y: float,
    }

    // This is also an item statement.
    fn foo() -&gt; Point {
        Point { x: 42.0, y: -3.14 }
    }

    // Technically this is a statement, but `print` is an expression.
    print(foo());
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="literal-expressions"><a class="header" href="#literal-expressions">Literal Expressions</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unary-expressions"><a class="header" href="#unary-expressions">Unary Expressions</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binary-expressions"><a class="header" href="#binary-expressions">Binary Expressions</a></h1>
<h2 id="equality"><a class="header" href="#equality">Equality</a></h2>
<p>The <a name="a001"></a>equals operator (<a name="a002"></a><code>==</code>) tests two expressions for equality and returns a <a name="a003"></a>bool.</p>
<pre><pre class="tunnel"><code class="language-dwarf">fn main() {
    print(1 == 1); // true
    print(1 == 2); // false
}</code></pre></pre>
<blockquote>
<p>Equality is a tricky thing.
There is reference equality, and value equality.
I've taken the perspective that if you can point to two different things, even if they are identical, they are still two different things.
This is reference equality.</p>
<p>Equality is transitive.
There is exactly one <word> unique representation of <code>1</code> in the language, and in the CPU.
That is why the following works.</p>
<pre><pre class="tunnel"><code class="language-dwarf">fn main() {
    let a = 1;
    let b = 1;
    print(a == b); // true
}</code></pre></pre>
<pre><pre class="tunnel"><code class="language-dwarf">struct Foo {}
struct Bar { bar: int }

fn main() {
    let a = Foo {};
    let b = Foo {};
    let e = b;
    print(e == b); // *true*
    let c = 1;
    let d = c;
    print(a == b); // *true*
    print(c == d); // true? false? *true*!

    let f = Bar { bar: 1 };
    let g = Bar { bar: 1 };
    let h = f;
    print(h == f); // true
    print(f == g); // true? false? *true*!
    f.bar = 2;
    print(f == g); // true? false? *false*!
    print(h == f); // true? false? *true*!
}</code></pre></pre>
<p>That said, it's a matter of perspective.
<a name="a004"></a>ChaCha knows about references, but dwarf does not.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="built-in-types"><a class="header" href="#built-in-types">Built-in Types</a></h1>
<p>dwarf contains a handful of primitive <a name="a001"></a>types.</p>
<h2 id="string"><a class="header" href="#string">String <a name="a002"></a></a></h2>
<p><a name="a003"></a></p>
<p>The string type is a wrapper for Rust's <code>String</code> type.
That is to say that it is a proper unicode string, encoded as UTF-8.</p>
<pre><pre class="tunnel"><code class="language-dwarf"><span class="boring">#fn main() {
</span>let s: string = &quot;Hello, world!🎉💥&quot;;

// Note the addition operator below.
print(s + &quot;\n&quot;);

// Strings are also iterable.
for c in s {
    print(c + &quot;\n&quot;);
}

// Of course you can fetch the length of a string.
let len = s.len();

// Note that indexing into a string is zero based. Also, we are indexing by
// unicode graphemes, which is a &quot;printable character&quot;.
chacha::assert_eq(s[len - 1], &quot;💥&quot;);
chacha::assert_eq(s[len - 2], &quot;🎉&quot;);
chacha::assert_eq(s[len - 9], &quot; &quot;);

// index into a string with a range.
print(&quot;{0}{1}\n&quot;.format(s[0..5], s[len - 3])); // Hello!

// Strings also support substitution via the `format` method.
// The string contains {?}, where ? is a number that corresponds to a positional
// argument to the `format` method. Like most everything else in dwarf, the
// arguments to the method are arbitrary expressions.
print(&quot;The length of the string is {0}. {0} * {0} = {1}\n&quot;.format(len, len * len));

let answer = 42;
let question = &quot;Huh?&quot;;
let msg = &quot;The answer to life, the universe, and everything is {1}. {0} Really, {1}\n&quot;;
print(msg.format(question, answer));
<span class="boring">}</span></code></pre></pre>
<h2 id="vector--list"><a class="header" href="#vector--list">Vector / List <a name="a004"></a></a></h2>
<p>The vector type is a wrapper for Rust's <code>Vec</code> type.
That is to say that it is a growable array.</p>
<p>At this time it's not possible to name the type of this, which is why there's a slash in the heading.
In order to name this type dwarf would need to first support generics.
This is likely to happen in the near future.</p>
<pre><pre class="tunnel"><code class="language-dwarf"><span class="boring">#fn main() {
</span>// 🚧 I need some sort of example. What do I want to do with these? There are
// all sorts of iterator functions that we could surface, but I'd pretty much
// need closures to do that.
// And now we have closures! So I need to get to this.
let c = [1, 2, 3, 4, 5];

let func = fn (x: int) -&gt; int {
    return x * x;
};

print(func());

<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="user-defined-types"><a class="header" href="#user-defined-types">User-defined Types</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chacha-runtime-reference"><a class="header" href="#chacha-runtime-reference">ChaCha Runtime Reference</a></h1>
<p>The interpreter is started via the <code>dwarf</code> binary:</p>
<pre><code class="language-console">Usage: dwarf [OPTIONS] [SOURCE] [-- &lt;ARGS&gt;...]

Arguments:
  [SOURCE]
          Dwarf Source File

          Local path, or URL of the source file to execute.

  [ARGS]...
          Dwarf main arguments

          These arguments are passed on to the dwarf `main` function.

Options:
  -d, --dap
          Debug Adapter Protocol (DAP) Backend

          Enable the DAP backend. This will start a TCP server on port 4711.

  -r, --repl
          Post-execution behavior

          Drop into the REPL after executing the source file.

  -b, --banner
          Print the dwarf banner

      --bless
          Bless a test

          This is only useful if you are writing tests for dwarf. I'd really like it if clap had hidden arguments.

      --uber
          Do uber stuff

          This is like sudo mode. You probably don't want this.

  -s, --stdin
          Stdin

          Read source file from stdin.

  -h, --help
          Print help (see a summary with '-h')

  -V, --version
          Print version
</code></pre>
<h2 id="args"><a class="header" href="#args">args</a></h2>
<p>Command line arguments are made available to a running program as a <a name="a001"></a> <a href="./reference/built-in-types.html#vector">vector</a> of <a name="a002"></a> <a href="./reference/built-in-types.html#string">strings</a> via the <code>chacha::args</code> function:</p>
<pre><pre class="tunnel"><code class="language-dwarf">fn main() {
    for arg in chacha::args() {
        print(arg + &quot;\n&quot;);
    }
}</code></pre></pre>
<h2 id="parse-and-eval"><a class="header" href="#parse-and-eval">Parse and Eval</a></h2>
<p>Misfortunately I haven't hacked all the HTTP nonsense necessary to pass command line arguments from here.
I might get to it before release.</p>
<h2 id="typeof"><a class="header" href="#typeof">typeof</a></h2>
<p>This is exactly what it sounds like.
Pass a value, and see what type it is:</p>
<pre><pre class="tunnel"><code class="language-dwarf"><span class="boring">#fn main() {
</span>print(&quot;42's type: {0}\n&quot;.format(chacha::typeof(42)));
print(&quot;42.0's type: {0}\n&quot;.format(chacha::typeof(42.0)));
print(&quot;true's type: {0}\n&quot;.format(chacha::typeof(true)));
print(&quot;false's type: {0}\n&quot;.format(chacha::typeof(false)));
print(&quot;[0, 1, 2, 3]'s type: {0}\n&quot;.format(chacha::typeof([0, 1, 2, 3])));
print(&quot;0..100's type: {0}\n&quot;.format(chacha::typeof(0..100)));
<span class="boring">}</span></code></pre></pre>
<pre><pre class="tunnel"><code class="language-dwarf"><span class="boring">#fn main() {
</span><span class="boring">}</span></code></pre></pre>
<pre><pre class="tunnel"><code class="language-dwarf"><span class="boring">#fn main() {
</span><span class="boring">struct Foo {}
</span>//print(&quot;Foo\{\}'s type: {0}\n&quot;.format(chacha::typeof(Foo{})));
print(&quot;{0}\n&quot;.format(chacha::typeof({})));
print(&quot;{0}\n&quot;.format(chacha::typeof([&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;])));
print(&quot;\&quot;42\&quot;'s type: {0}\n&quot;.format(chacha::typeof(&quot;42&quot;)));
// print(chacha::typeof(()) );
<span class="boring">}</span></code></pre></pre>
<pre><pre class="tunnel"><code class="language-dwarf"><span class="boring">#fn main() {
</span><span class="boring">struct Complex {
</span><span class="boring">    re: float,
</span><span class="boring">    im: float,
</span><span class="boring">}
</span>
impl Complex {
    fn square(self) {
        self.re = self.re * self.re - self.im * self.im;
        self.im = 2.0 * self.re * self.im;
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="for-hackers"><a class="header" href="#for-hackers">For Hackers</a></h1>
<blockquote>
<p>&quot;The best programmers are not always the most productive. They are the ones who are able to let go of their ego and embrace the Tao. They write code that is simple and elegant, yet powerful and efficient. They understand that the best code is the code that is not written. They know that the best way to solve a problem is to avoid it altogether. They are like water, which flows around obstacles and finds the path of least resistance. They are the masters of their craft, yet they remain humble and open to learning. They are the ones who create software that is a joy to use and a pleasure to maintain.&quot;</p>
</blockquote>
<p>First off, the code is pretty rough.
I've been hacking on this pretty much non-stop for three months.
And the code generator is still in it's infancy too.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parser"><a class="header" href="#parser"><a name="a001"></a>Parser</a></h1>
<blockquote>
<p>The problem with parser generators is that you need to understand how a parser works in order to use one.
If you don't understand how a parser works, you're going to get confused, and frustrated.
The next thing you know parser generators are terrible, evil beasts from the nether depths of the endless turtle Ouroboros.
You'll write your own, buggy, hard to maintain parser, or you'll learn how the work, and build a well-behaved parser.
In the latter case, you'll <em>then</em> be able to use a parser generator.</p>
</blockquote>
<p>So, I couldn't get the evil parser generator to pay attention to my needs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-path-to-async"><a class="header" href="#a-path-to-async">A Path to <a name="a001"></a>Async</a></h1>
<h2 id="async-implementation"><a class="header" href="#async-implementation">Async Implementation</a></h2>
<p>dwarf is written in Rust, and Rust's asynchronous support comes in the form of <a name="a002"></a><a href="https://docs.rs/futures/latest/futures/"><code>futures</code></a>
It thus makes sense that dwarf's async model be implemented using futures.
And indeed, that is part of the story.
The full story is however a bit more complex and nuanced.</p>
<p>A simple way of looking at dwarf is an expression evaluation engine.
<code>Value</code>s go in, and values come out.
Given this, we have a few places where it makes sense to crack the shell and look inside.</p>
<p>If you consider futures in Rust, it's all about the return type.
The return type is even named after the abstraction: <code>Future</code>.
Since evaluation of an expression returns a value, it makes sense to leverage that and add a <code>Future</code> to our Value enum.
Since this is Rust, what starts as a good idea quickly becomes complex.</p>
<h2 id="delving-into-dwarf"><a class="header" href="#delving-into-dwarf">Delving into dwarf</a></h2>
<p>There are a bare few things that we need to know about dwarf before we can start to discuss adding async support.</p>
<p>Perhaps the most significant aspect is that nearly everything in dwarf is an expression.
Expressions are evaluated using the <code>eval_expression</code> function in <a name="a003"></a>ChaCha, the interpreter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-types"><a class="header" href="#generic-types">Generic Types</a></h1>
<p>Today we're going to talk about how generics are implemented in dwarf.
Generics are a type of polymorphism, which is a way to have one chunk of code work with multiple types.
In the generic code, the abstract type is specified by a single capital letter.
When the code is compiled the abstract type is replaced with a concrete type.
The concrete type is inferred from the call site.</p>
<p>Below are examples of a generic function and a generic type, as well as a usage of each.</p>
<pre><pre class="tunnel"><code class="language-dwarf">// This is a generic function.
// It takes a type T and returns a value of type T + 42.
fn plus_42&lt;T&gt;(x: T) -&gt; T {
    x + 42
}

// This is a generic type.
// It takes a type T and stores a value of type T.
 struct Box&lt;U&gt; {
     value: U,
 }

 impl Box&lt;U&gt; {
     fn display(self) {
         print(&quot;Box&lt;{0}&gt;\n&quot;.format(self.value));
     }
 }

fn main() {
    // Here we call the generic function with an int.
    let x = plus_42(0);
    print(&quot;{0}\n&quot;.format(x));

    // And here with a float.
    let y = plus_42(&quot;Hello World, the answer is &quot;);
    print(&quot;{0}\n&quot;.format(y));

    // Here we create a Box that stores a float.
    let z = Box{ value: 0.42 };
    z.display();

    // Let's box a list now.
    let α = Box{ value: [1, 2, 3] };
    α.display();

    // Let's try something interesting...
    let β = Box{ value: plus_42(&quot;&quot;) };
    β.display();
    print(β);
}</code></pre></pre>
<p>In the examples above notice that the generic labels, <code>T</code> and <code>U</code>, are used in the function and type definitions.
The code in the <code>main</code> function uses the generic function and type with no label to be seen.
That is because concrete types are used in the non-generic, non-definition code.</p>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<p>So what does it take to make this happen in dwarf?
Well, like everything else, there's a parser piece, an extruder piece, and an interpreter piece.</p>
<p>The <a name="a001"></a>parser reads the input and looks for generic annotations where appropriate.
The <a name="a002"></a>extruder takes the output of the parser and builds the AST, substituting the generic placeholder with a concrete type.
The <a name="a003"></a>interpreter then takes the AST and evaluates it.</p>
<h3 id="parser-1"><a class="header" href="#parser-1">Parser</a></h3>
<p>Rather than go into how the parser works, which is covered in the <a href="hacker/dwarf/../arch/parser.html">parser</a> section of the hacker book,</p>
<h3 id="extruder"><a class="header" href="#extruder">Extruder</a></h3>
<h4 id="grace-ast-model"><a class="header" href="#grace-ast-model"><a name="a004"></a>Grace <a name="a005"></a>AST Model</a></h4>
<p>Below is an approximation of (a part of) the model that is used to generate (a part of) the dwarf abstract syntax tree (<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">AST</a>).
The diagram is UML-ish, and says that <strong>Type</strong> is a supertype, and everything connected by an <strong>R1</strong> label is it's subtype.
<strong>Field</strong> has two relationships, <strong>R3</strong> and <strong>R4</strong>, to <strong>Struct</strong> and <strong>Type</strong> respectively.
These relationships are backed by &quot;referential attributes&quot; whose purpose is to store the relationship data.
In the case of <strong>Field</strong>, <strong>struct</strong> formalizes <strong>R3</strong> and <strong>type</strong> formalizes <strong>R4</strong>.</p>
<p>The points worth reflecting upon are that <strong>Type</strong> is a generalization over all of the dwarf types.
Also, <strong>Field</strong> and <strong>Generic</strong> both have relationships to <strong>Type</strong>. separate from <strong>R1</strong>.</p>
<pre class="mermaid">classDiagram
    Type &lt;|-- Generic : R1
    Type &lt;|-- Integer : R1
    Type &lt;|-- Struct : R1
    Type &lt;|-- Etcetera : R1
    Generic --&gt; &quot;0..1&quot; Type : R2
    Struct &quot;1&quot; &lt;-- &quot;0..*&quot; Field : R3
    Field --&gt; Type : R4

    class Type
    &lt;&lt;Enumeration&gt;&gt; Type

    class Generic {
        label: String
        *type: Option~R2_Type~
    }

    class Struct {
        name: String
    }

    class Field {
        name: String
        *struct: R3_Struct
        *type: R4_Type
    }
</pre>
<p>There is a real model that is much more extensive that is used to generate the AST code.
Below is the generated code for the actual <strong>Type</strong>, called <code>ValueType</code> in the code.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum ValueType {
    Char(Uuid),
    Empty(Uuid),
    Enumeration(Uuid),
    Function(Uuid),
    Future(Uuid),
    Generic(Uuid),
    Import(Uuid),
    Lambda(Uuid),
    List(Uuid),
    ObjectStore(Uuid),
    Plugin(Uuid),
    Range(Uuid),
    Struct(Uuid),
    Task(Uuid),
    Ty(Uuid),
    Unknown(Uuid),
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>Ty</code> variant is actually imported from yet another, fundamental, model.
It's definition is below, ond contains what one might expect, given what is missing from above.
These are the fundamental modeling types, whereas above are the dwarf types.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Ty {
    Boolean(Uuid),
    External(Uuid),
    Float(Uuid),
    Integer(Uuid),
    Object(Uuid),
    String(Uuid),
    Uuid(Uuid),
}
<span class="boring">}</span></code></pre></pre>
<pre><pre class="tunnel"><code class="language-dwarf"><span class="boring">#fn main() {
</span>let definition = &quot;
    struct Box&lt;T&gt; {
        value: T,
    }
&quot;;

print(definition);
let ast = chacha::parse(definition);
print(ast);
<span class="boring">}</span></code></pre></pre>
<p>Mention something about assuming the type of a field expression, and then having to use that to check type.</p>
<h3 id="interpreter"><a class="header" href="#interpreter">Interpreter</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="index"><a class="header" href="#index">Index</a></h1>
<p><code>()</code>,<br/>
      <a href="overview.html#a003">Language Walkthrough</a><br/>
AST,<br/>
      <a href="hacker/dwarf/generics.html#a005">Generic Types</a><br/>
Async,<br/>
      <a href="hacker/arch/chacha/async.html#a001">Async Implementation</a><br/>
block,<br/>
      <a href="overview.html#a005">Language Walkthrough</a><br/>
block expression,<br/>
      <a href="overview.html#a011">Language Walkthrough</a><br/>
bool,<br/>
      <a href="reference/expressions/binary.html#a003">Binary Expressions</a><br/>
ChaCha,<br/>
      <a href="introduction.html#a003">Introduction</a>,<br/>
      <a href="overview.html#a018">Language Walkthrough</a>,<br/>
      <a href="tutorials/mandelbrot/complex.html#a006">Coding a Complex Type</a>,<br/>
      <a href="reference/expressions/binary.html#a004">Binary Expressions</a>,<br/>
      <a href="hacker/arch/chacha/async.html#a003">Async Implementation</a><br/>
command line arguments,<br/>
      <a href="overview.html#a020">Language Walkthrough</a><br/>
comparison operators,<br/>
      <a href="overview.html#a017">Language Walkthrough</a><br/>
Complex numbers,<br/>
      <a href="tutorials/mandelbrot/complex.html#a001">Coding a Complex Type</a><br/>
condition,<br/>
      <a href="overview.html#a013">Language Walkthrough</a><br/>
conditional expression,<br/>
      <a href="overview.html#a012">Language Walkthrough</a><br/>
dwarf,<br/>
      <a href="introduction.html#a002">Introduction</a><br/>
else expression,<br/>
      <a href="overview.html#a015">Language Walkthrough</a><br/>
empty,<br/>
      <a href="overview.html#a004">Language Walkthrough</a><br/>
equals, see <code>==</code><br/>
expression,<br/>
      <a href="overview.html#a021">Language Walkthrough</a><br/>
      <code>==</code>,<br/>
            <a href="reference/expressions/binary.html#a001">Binary Expressions</a>,<br/>
            <a href="reference/expressions/binary.html#a002">Binary Expressions</a><br/>
      <code>if</code>,<br/>
            <a href="overview.html#a016">Language Walkthrough</a><br/>
      <code>print</code>,<br/>
            <a href="tutorials/mandelbrot.html#a003">Mandelbrot Set</a><br/>
      struct expression,<br/>
            <a href="tutorials/mandelbrot/complex.html#a005">Coding a Complex Type</a><br/>
extruder,<br/>
      <a href="hacker/dwarf/generics.html#a002">Generic Types</a><br/>
format,<br/>
      <a href="reference/built-in-types.html#a003">Built-in Types</a><br/>
fractal,<br/>
      <a href="tutorials/mandelbrot.html#a002">Mandelbrot Set</a><br/>
function,<br/>
      <a href="overview.html#a001">Language Walkthrough</a>,<br/>
      <a href="overview.html#a010">Language Walkthrough</a><br/>
future, see futures<br/>
<code>futures</code>,<br/>
      <a href="hacker/arch/chacha/async.html#a002">Async Implementation</a><br/>
Grace,<br/>
      <a href="hacker/dwarf/generics.html#a004">Generic Types</a><br/>
Hello World,<br/>
      <a href="introduction.html#a001">Introduction</a><br/>
interpreter,<br/>
      <a href="hacker/dwarf/generics.html#a003">Generic Types</a><br/>
item,<br/>
      <a href="overview.html#a008">Language Walkthrough</a><br/>
<code>main</code>,<br/>
      <a href="overview.html#a019">Language Walkthrough</a><br/>
Mandelbrot set,<br/>
      <a href="tutorials/mandelbrot.html#a001">Mandelbrot Set</a><br/>
Parser,<br/>
      <a href="hacker/arch/parser.html#a001">Parser</a><br/>
parser,<br/>
      <a href="hacker/dwarf/generics.html#a001">Generic Types</a><br/>
statement,<br/>
      <a href="overview.html#a002">Language Walkthrough</a>,<br/>
      <a href="reference/statements.html#a001">Statements</a><br/>
      Expression Statement,<br/>
            <a href="reference/statements.html#a004">Statements</a><br/>
      Item Statement,<br/>
            <a href="reference/statements.html#a006">Statements</a><br/>
      <code>let</code>,<br/>
            <a href="overview.html#a006">Language Walkthrough</a>,<br/>
            <a href="overview.html#a022">Language Walkthrough</a>,<br/>
            <a href="reference/statements.html#a002">Statements</a>,<br/>
            <a href="reference/statements.html#a003">Statements</a><br/>
      Let Statement, see <code>let</code><br/>
      Result Statement,<br/>
            <a href="reference/statements.html#a005">Statements</a><br/>
static method,<br/>
      <a href="tutorials/mandelbrot/complex.html#a007">Coding a Complex Type</a><br/>
string,<br/>
      <a href="reference/built-in-types.html#a002">Built-in Types</a>,<br/>
      <a href="chacha.html#a002">ChaCha Runtime Reference</a><br/>
<code>struct</code>,<br/>
      <a href="tutorials/mandelbrot/complex.html#a004">Coding a Complex Type</a><br/>
struct,<br/>
      <a href="overview.html#a009">Language Walkthrough</a><br/>
then expression,<br/>
      <a href="overview.html#a014">Language Walkthrough</a><br/>
tuple,<br/>
      <a href="tutorials/mandelbrot/complex.html#a002">Coding a Complex Type</a><br/>
types,<br/>
      <a href="reference/built-in-types.html#a001">Built-in Types</a><br/>
      <code>float</code>,<br/>
            <a href="tutorials/mandelbrot/complex.html#a003">Coding a Complex Type</a><br/>
variable,<br/>
      <a href="overview.html#a007">Language Walkthrough</a><br/>
vector,<br/>
      <a href="reference/built-in-types.html#a004">Built-in Types</a>,<br/>
      <a href="chacha.html#a001">ChaCha Runtime Reference</a><br/></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="postface"><a class="header" href="#postface">Postface</a></h1>
<p>I started dwarf on April 6, 2023.
It was meant to be as a DSL for it's parent project <code>sarzak</code>.
I wrote the date down because I wanted to know how long this side-trip took once I was done.
I was concerned that I'd spend too long on it, and I was excited to put it to use.
As you can see, it's all sort of gotten away from me since then.
It's a long way from being done, and I keep adding features.
It's grown far beyond the needs of my DSL, and yet I keep tweaking it.
I guess I'm having fun. 😀</p>
<p>Dwarf looks a lot like Rust — that's on purpose.
You see, I wanted to use <code>sarzak</code> to generate Rust code for dwarf.
Making that work was enough of a mental load.
Adding &quot;programming language design&quot; was more than I needed to deal with.
Like I already mentioned, dwarf is meant to be a DSL, and I plan on hacking on it quite a bit.
The more it looks like, and acts like Rust, the happier a cowboy be me.</p>
<p>Dwarf contains generated code — a lot of it.
Counting lines of code is a pretty terrible metric.
&quot;Semantic density&quot; varies within a language, and between languages.
Should you include comments?</p>
<p>Now that we've established <code>loc</code> is useless, here are some numbers.
As I write this there are (15/2)k (code/comments) <code>loc</code> that I've written myself.
The last time I generated the LuDog/AST-dwarf interface code it was 11k/300.
Each LuDog/AST backend &quot;store&quot; is (9/1.4)k, and I could generate at least five (Rc, (parking_lot | std)::Mutex, (parking_lot | std)::RwLock). <sup class="footnote-reference"><a href="#std">1</a></sup>.
I have no idea what I'll end up actually shipping.
I won't bother to include the generated code upon which the stores depend.
Regardless, there are some metrics to gain insight into the ratio of generated to hand-written code.</p>
<p>The code generator is called <code>grace</code>, which I began in January 2023.
Dwarf is in fact necessary for me to continue work on grace.
Once I've escaped this recursive rabbit hole, I'll publish the whole mess.</p>
<p>So really, this is an experiment.
An exciting, fun, experiment</p>
<p>— Keith Star (June 8, 2023)</p>
<p><img src="images/cwarf.png" alt="Cwarf Painting" /></p>
<div class="footnote-definition" id="std"><sup class="footnote-definition-label">1</sup>
<p>After benchmarking the differences between Parking Lot and std, I got to digging.
Apparently the std sync stuff was recently updated.</p>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
